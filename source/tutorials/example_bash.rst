Example BASH Scripts for Common Tasks
=====================================

AaronTools command line scripts (CLSs, see :doc:`../cls/list`) make it simple to write BASH scripts to automate many routine tasks.
A few examples are provided here to get you started!
More examples will be added over time to make this a sort of 'cookbook' of AaronTools BASH scripts
If you have a BASH script that uses AaronTools that you'd like us to add send it our way (similarly, if there is something you are trying to do using AaronTools contact us and we can (possibly) help).

Note that these BASH scripts assume you have correctly installed AaronTools (see :doc:`install`) and configured the :doc:`../other_docs/job_templates` to allow for job submission to a local queue.

Optimization and Frequencies
----------------------------

Perhaps the most common task in routine quantum chemistry applications is optimizing geometries for a set of molecules and computing harmonic vibrational frequencies.
This can be done using AaronTools CLSs using any quantum chemistry software package.
Here we use Gaussian as an example, but trivial changes to the scripts below would instead use Q-Chem, ORCA, or Psi4.

For instance, suppose we have a set of XYZ files containing initial geometries that we would like to optimize.
These geometries could be for a set of molecules from some other source or conformations of a single molecule generated by
`CREST <https://crest-lab.github.io/crest-docs/>`_ for example.
The following script will submit wB97XD/def2-TZVP optimization and frequency jobs (requesting 8 cores/processors and 12 GB of memory) on all XYZ files in the current directory.
It uses :doc:`../cls/makeInput` to make a Gaussian input file from each XYZ file and then calls :doc:`../cls/jobSubmit` to submit a job to the queue:

.. literalinclude:: bash/opt_all
   :language: bash

If these XYZ files were different conformations of the same molecule, after all optimizations were complete we could then identify the unique ones using :doc:`../cls/unique`, for example.

If initial XYZ files are not available, we can instead build all molecules from a list of SMILES or IUPAC names (using :doc:`../cls/fetchMolecule`) and pipe this into :doc:`../cls/makeInput` to build input files for the optimization + frequency computations.
For instance, suppose we have a file :code:`molecules` that contains a list of IUPAC names:

.. literalinclude:: bash/opt_all_iupac
   :language: bash

Because many IUPAC names contain spaces and/or other non-alphanumeric characters (e.g. 1,3-butadiene) we remove those to form the name of the input file using the BASH command :code:`tr -dc [:alnum:]`.

The above script can be easily extended to run optimizations/frequency jobs using different combinations of DFT functionals and basis sets:

.. literalinclude:: bash/opt_all_iupac_benchmark
   :language: bash


Checking and Rerunning Jobs
---------------------------

After running the above optimizations, it is necessary to check two things:


#. Did the computations all finish correctly?
#. Are all optimized structures energy minima (no imaginary frequencies)

The following script will check these.
For jobs that did not generate an output file, the script just resubmits the original input file.
For jobs that ran but did not finish, a new job is submitted using the last geometry from the previous attempt using the same level of theory used in the corresponding output file.
For optimizations that ended with one or more imaginary vibrational frequency, the script displaces along the (lowest magnitude) imaginary vibrational mode using :doc:`../cls/follow` and re-optimizes.
We'll assume that we are working with a set of XYZ files, as in the first example above.
The modifications to instead use a list of IUPAC names should be obvious.
Changing the level of theory and/or quantum chemistry package should also be straightforward.

.. literalinclude:: bash/check_jobs
   :language: bash


Potential Energy Scans for Stacked Dimers
-----------------------------------------

Density Functional Theory
*************************

AaronTools CLSs make it trivial to run scans over different coordinates for non-bonded dimers (e.g. see `this recent paper <https://pubs.acs.org/doi/10.1021/jacs.5c03169>`_).
For instance, the script below will run wB97X-D/def2-TZVP single point energies on the benzene dimer as a function of x- and z-coordinates (with a fixed monomer geometry) from x = 0 to 5 A and z = 3 - 4 A.
It assumes that there is a local file called `benzene.xyz` that contains the coordinates of benzene in the xy-plane that is oriented with a vertex along the x-axis.

.. literalinclude:: bash/dimer_scan
   :language: bash

Note that :doc:`../cls/combineMonomers` can only accept geometries from STDIN or from a list of files, so we save the shifted benzene geometry to :code:`temp.xyz` before combining with :code:`benzene.xyz` to build each dimer.

We could modify this to instead run the T-shaped benzene dimer by first rotating the second benzene by 90 degrees around the y-axis (e.g. :code:`rotate.py benzene.xyz -x y -a 90`) and then piping this into :code:`translate.py -v $x 0 $z -o temp.xyz`.

We can also use AaronTools to gather the energies after making sure all of the single points ran to completion:

.. literalinclude:: bash/gather_scan
   :language: bash

.. _bash_SAPT_calculations:

Symmetry Adapted Perturbation Theory (SAPT)
*******************************************

To instead run SAPT computations (using Psi4), we need to make some minor modifications.
SAPT computations provide interaction energies between non-bonded molecules.
As such, these computations require a dimer (for example) to be partitioned into individual components.
In order to use :code:`makeInput.py` to build a Psi4 SAPT input file we will exploit the fact that Psi4 can automatically detect components for SAPT computations using :code:`activate(auto_fragments())`.
Because this needs to appear in the Psi4 input file before the job, we pass this to :code:`makeInput.py` using the :code:`--before-job` option.
Note that with Psi4 we need to explicitly specify that Psi4 calculate the energy (by passing :code:`-e` to :code:`makeInput.py`).

.. literalinclude:: bash/dimer_scan_sapt
   :language: bash

If Psi4 does not properly recognize your monomers, or you want more control over how a given complex is divided, you will need to use the Python API.
See :ref:`python_SAPT_calculations`.

Finally, we can gather the SAPT data, printing both the individual components (electrostatics, exchange repulsion, induction, and dispersion) as well as the total SAPT0 interaction energy:

.. literalinclude:: bash/gather_scan_sapt
   :language: bash

